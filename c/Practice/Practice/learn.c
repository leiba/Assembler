/*
 Типы
*/
typedef signed char int8_t;              // -128 .. 128
typedef unsigned char uint8_t;           // 0 .. 255
typedef int int16_t;                     // -32768 .. 32767
typedef unsigned int uint16_t;           // 0 .. 65535
typedef signed long int int32_t;         // -2147483648 .. 2147483647
typedef unsigned long int uint32_t;      // 0 .. 4294967295
typedef signed long long int int64_t;    // -9223372036854775808 .. 9223372036854775807
typedef unsigned long long int uint64_t; // 0 .. 18446744073709551615

/*
 Синтаксис
*/
extern int n = 1;      // Область видимости во всех файлах
const int x = 1;       // Константа
enum(one, two, three); // Перечисление, без значений
n = sizeof(n);         // Занимаемое место в памяти в байтах, 2
func(int n);           // Прототип функции до ее определения, затычка

/*
 Статические переменные
*/
int plus5(){
	static int n; // Инициализируется как 0, заоминается значение между вызовами
	return n + 5;
}

/*
 Структуры. 
 Допускаются вложенные. 
 Могут быть параметрами и возвращаемыми значениями функций
*/
struct Date {
	int year;
	int month;
	int day;
};
struct Date myDate;             // Пустая инициализация
struct Date myDate = {28,5,90}; // Инициализация с установкой значений
myDate.day;                     // Обращение к полям струткуры

/*
 Указатели
 Может ссылатся на переменную, функцию, константу
*/
int *u;       // Указатель на целое число. 
int x = 1, y;
u = &x;       // Присваеваем указателю адрес переменной в памяти 
y = *u;       // Присваеваем переменной y, значение находящиеся по адресу указателя
*u = 2;       // Присваеваем переменной x, значение. Ложим в адрес переменной значение
u = 0xff;     // Присваеваем указателю произвольный участок памяти

/*
 Указатели как параметры функции
 Можно возвращать такми способом больше 1 значения
*/
int sum(int *a, int *b){
	int s = *a + *b; // В указателях содержатся значения
	*a = *a / s;     // Меняем значение по указателю
	*b = *b / s;     // Меняем значение по указателю
	return s;        // Возвращаемое значение
}

/*
 Указатели на структуры
*/
struct Date myDate;
struct Date *u;
u = &myDate;
u->day = 7;         // Присваивание значения по указателю
(*u).day = 7;       // Присваивание значения через разименовывание по указателю

/*
 Указатели как поля структуры
*/
struct Dates {
	int day,
	struct Dates *next
};
struct Dates myDates, myDates2;
myDates.next = &myDates2;
myDates.next->day;              // Обращение по указателю к вложенной структуре

/*
 Массивы
 Название массива, это указатель на его 0й элемент
*/
int[2] m0;         // Объявление пустого массива
int[] m1 = {0, 1}; // Объявление заполненного массива
m1[1] = 1;         // Присваивание значения элементу массива
*(m1 + 1) = 1;     // Присваивание значения элементу массива
m1[1];             // Получение значения элемента
*(m1 + 1);         // Получение значения элемента

/*
 Многомерные массивы
 Данные хранятся в памяти последовательно,
 поэтому справедливы разные способы инициализации и обращения 
*/
int[][] m = {0, 0};
int[][] m = {{0}, {0}}; // Два одинаковых объявления
m[1][0];                // Обращение к 0му элементу 1 вложенного массива
*(m + 1);               // Обращение к 0му элементу 1 вложенного массива

/*
 Строки
 Это массивы типа char
 Реальная длина на 1 больше количества символов, в конце добавляется \0
*/ 
char[] = "My String";

// Логические опреации
n = 1 << 1;                  // Разрядный сдвиг влево
n = 1 >> 1;                  // Разрядный сдвиг вправо
n = ~1;                      // Инвертирует каждый разряд 0 -> 1, 1 -> 0
n = 0b01010010 ^ 0b01011000; // 0b00001010, 1 если отличаются, 0 если совпадают
n = 0b00100100 | 0b00100001; // 0b00100101, 1 если есть хоть 1 единица
n = 0b00110000 & 0b00100000; // 0b00100000, 1 если обе 1

/*
 Установка разрядов в 1 с обнулением остальных
*/
n = (1 << 3);            // Установит 4 разряд в 1
n = (1 << 3) | (1 << 5); // Установит 4 и 6 разряд в 1
n = 0b00001000;			 // Установит 4 разряд в 1

/*
 Установка разрядов в 1 без обнуления остальных
*/
n |= (1 << 3);  		  // Установит 4 разряд в 1
n |= (1 << 3) | (1 << 5); // Установит 4 и 6 разряд в 1
n |= 0b00001000;		  // Установит 4 разряд в 1

/*
  Сброс разряда в 0 без обнуления остальных
*/
n &= ~(1 << 3)		        // Сбросит 4 разряд в 0
n &= ~(1 << 3) & ~(1 << 5); // Сбросит 4 и 6 разряд в 0
n &= 0b00001000;		    // Сбросит 4 разряд в 0

/*
 Сброс разряда в 0 с установкой в 1 остальных
*/
n = ~(1 << 3);             // Установит 4 разряд в 0, остальные в 1
n = ~(1 << 3) | ~(1 << 5); // Установит 4 и 6 разряд в 0, остальных в 1
n = 0b11110111;			   // Установит 4 разряд в 0, остальные в 1

/*
 Проверка разряда на 0
*/
if (0 == (n & (1 << 3))) {} // Проверка, что в 4-м разряде 0
if (~n & (1 << 3)) {}       // Проверка, что в 4-м разряде 0
	
/*
 Проверка разряда на 1
*/
if (0 != (n & (1 << 3))) {}        // Проверка, что в 4-м разряде 1
if (n & (1 << 3)) {}               // Проверка, что в 4-м разряде 1
if ((n & (1 << 3)) == (1 << 3)) {} // Проверка, что в 4-м разряде 1
	
/*
 Ожидание появления 1 в разряде
*/
while (~n & (1 << 3));   // Ожидание 1 в 4м разряде
while (!(n & (1 << 3))); // Ожидание 1 в 4м разряде

/*
 Ожидание появления 0 в разряде
*/
while (n & (1 << 3)); // Ожидание 0 в 4м разряде

/*
 Проверка состояния разрядов
*/
if ((n & 0b11100000) == 0b10100000) {} // Проверка разрядов 6-8 на значение 101
	
/*
 Бесконечные циклы
*/
while (1) {}
for(;;) {}

/*
 Функции ввода\вывода
*/

/*
 Директивы препроцессора
*/
#include <avr/io.h>                // Подключение файла из стандартной библиотеки
#include "file.h"                  // Подключение файла из той же апки что и исполняемый код
#define MyName "Le"                // Подстановка кода "Le" вместо MeName
#undef MyName                      // Отмена #define
#error "Error message"             // Генерация сообщения об ошибке компиляции

/*
 Макросы
 Не требуют типа данных, не забивают стек, выполняются быстрее
*/
#define max(a, b) (a > b ? a : b); // Вызов n = max(3, 4);
#define out(s) puts(#s);           // # Преобразовывает параметр в строку. Вызов out("Str");
#define concat(a, b) a ## b;       // ## Преобразовывает в конкатенацию. Вызов concat(1, 2);

/*
 Макросы с проверкой существования макросов
*/
#ifdef MyName             // Если определен макрос
	#define MyName2 "One"
#else                     // В противном случае
	#define MyName2 "Two"
#endif

#ifndef MyName            // Если не определен макрос
	#define MyName2 "One"
#else                     // В противном случае
	#define MyName2 "Two"
#endif

/*
 Макросы с условиями
*/
#if 1 == 2
	#define MyName2 "One"
#elif 1 == 3
	#define MyName2 "Two"
#else
	#error "Wrong rules"  // Генерируем сообщение об ошибке 
#endif

/*
 Прерывания
 http://www.nongnu.org/avr-libc/user-manual/group__avr__interrupts.html
*/

#include <avr/interrupt.h>
ISR(ADC_vect) {}           // Регистрирование обработчика прерывания

/*
 Порты
*/
DDRA |= 0b0000001;     // Установка порта A0 на вывод, по умолчанию 0 - ввод
PORTA |= 0b00000001;   // Установка 1 на выводе A0
n = PINA & 0b00000001; // Чтение бита из вывода